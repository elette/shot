package nlz;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.CookieHandler;
import java.net.CookieManager;
import java.net.URL;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Scanner;

import javax.net.ssl.*;
import javax.net.ssl.HttpsURLConnection;
import java.security.*;
import java.security.cert.*;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.bind.DatatypeConverter;

import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

import nlz.com.EventDefine;
import nlz.com.HashObject;
import nlz.com.InoutParameter;
import nlz.com.LoggingWriter;
import nlz.com.MessageDefine;
// This servlet serves retrieved streams data formatted to be displayed in charts
// It uses the Streams REST API to retrieve the streams data generated by spl/Main.spl
// It formats the data to be consumed by Dojo charts and serves the resulting data
// java/index.html retrieves this data
// java/src/ChartServlet.java serves index.html

public class DataRest {
    String pgmID        = "DataRest";
  private static String _baseURL = null;
  private static String _authToken = null;
  private static DataRetrievalThread _dataRetrievalThread;
  private static StringBuffer _formattedData = new StringBuffer("");
  private static float[] _pieTally = new float[] {0f,0f};
  private static CookieManager _cm = new CookieManager();

  // @Override
  public void DataRest() {
  }

  public int initialize(InoutParameter ioParam) {
	int resultInt = EventDefine.E_DOEXCUTE_INIT;
    try {
      readConnectionProperties();

      // Retain cookies between requests. This will make the application perform better
      CookieHandler.setDefault(_cm);

      // Retrieve the activeViews URL property for configured views with application name = Main (assuming exactly one exists)
      //URL configuredViewsURL = new URL(_baseURL + "/configuredviews?applicationName=Main&fields=activeViews");
      //URL configuredViewsURL = new URL(_baseURL + "/activeviews");
      URL activeViewsURL = new URL(_baseURL + "/activeviews");
//      JSONObject response = makeRestCall(configuredViewsURL, _authToken);
//      JSONArray configuredViews = (JSONArray)response.get("activeViews");
//      if (configuredViews.isEmpty()) {
//        throw new StreamsRestException("Configured view not found. Make sure the SPL application has been started and a view has been created and started. (See README steps 4 - 6).");
//      }
//      JSONObject configuredView = (JSONObject)configuredViews.get(0);
//
//      // Extract the active view ID for the first such active view (again, assuming exactly one exists)
//      String activeViewsUrl = (String)configuredView.get("viewitems");
//      //activeViewsUrl += "&fields=id";
//      URL activeViewsURL = new URL(activeViewsUrl);
        HashObject ho = ioParam.getInputHashObject();

		String viewName = (String)ho.get("View",HashObject.YES);
      JSONObject response = makeRestCall(activeViewsURL, _authToken);
      JSONArray activeViews = (JSONArray)response.get("activeViews");
      if (activeViews.isEmpty()) {
        throw new StreamsRestException("Active view not found. Make sure the SPL application has been started and a view has been created and started. (See README steps 4 - 6).");
      }
      JSONObject activeView ;
      String viewId = "";
      for (int i=0; i<activeViews.size(); i++) {
            activeView = (JSONObject)activeViews.get(i);
            viewId = (String)activeView.get("id");
            if (viewId.indexOf(viewName) != -1) break;
      }
System.out.println(">>>> activeView: \n" + viewId);

      // Determine the URL to access the streams data for this view
      URL getViewDataURL = new URL(_baseURL + "/activeviews/" + viewId + "/viewitems");
System.out.println(">>>> DataUrl: " + getViewDataURL);

      // Start a thread to retrieve the streams data for the view every second
	  if( _dataRetrievalThread != null ) {
		_dataRetrievalThread.interrupt();
		_dataRetrievalThread = null;
	  }
      _dataRetrievalThread = new DataRetrievalThread(getViewDataURL);
      _dataRetrievalThread.start();
		resultInt = EventDefine.E_DOEXCUTE_SUCCESS;
		ioParam.setResultURL("/jsp/com/listDom.jsp");
	  
    }
    catch (Exception e) {
      SimpleDateFormat dateFormat = new SimpleDateFormat();
      System.out.println(dateFormat.format(System.currentTimeMillis()));
      System.out.println("Exception: " + e.getMessage());
      e.printStackTrace();
    }
	return resultInt;
  }

	public int doGet(InoutParameter ioParam) {
        int resultInt = EventDefine.E_DOEXCUTE_INIT;
        HashObject ho = ioParam.getInputHashObject();
        try {
			// ioParam.setResultList(getFormattedData());
			ho.put("json", getFormattedData());

            ioParam.setResultURL("/jsp/json.jsp");
            resultInt = EventDefine.E_DOEXCUTE_SUCCESS;
            LoggingWriter.setLogDebug(pgmID,"@Business==== " + MessageDefine.M_SELECT_OK);
        } catch (Exception e) {
            resultInt = EventDefine.E_DOEXCUTE_ERROR;
            e.printStackTrace();
        }
        return resultInt;
    }

  private void readConnectionProperties() throws IOException {
    Properties props = new Properties();
    props.load(new FileInputStream(DataRest.class.getResource("").getPath() + "streams.properties"));

    _baseURL = props.getProperty("url") + props.getProperty("instanceID");

    // Build authentication token for basic authentication
    String authID = props.getProperty("authID");
    String authPass = props.getProperty("authPass");
    String userInfo = authID + ":" + authPass;
    _authToken = "Basic " + DatatypeConverter.printBase64Binary(userInfo.getBytes());

    // Set the java truststore system properties to validate the Streams server is trusted
    String tSLoc = DataRest.class.getResource("").getPath() + props.getProperty("keystorePath") + props.getProperty("keystoreFile");
    String tSPass = props.getProperty("keystorePass");

    System.setProperty("javax.net.ssl.trustStore", tSLoc);
    System.setProperty("javax.net.ssl.trustStorePassword", tSPass);
  }

private static class CustomizedHostnameVerifier implements HostnameVerifier {
    public boolean verify(String hostname, SSLSession session) {
        return true;
    }
}

  private JSONObject makeRestCall(URL url, String authToken) throws IOException, StreamsRestException {
    InputStream responseStream = null;
    InputStreamReader responseStreamReader = null;

    try {
      HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();

      conn.setHostnameVerifier(new CustomizedHostnameVerifier());
      conn.setRequestProperty("Authorization", authToken);
      conn.setRequestMethod("GET");

      conn.connect();

      if (conn.getResponseCode() != 200) {
        throw new StreamsRestException("REST call to " + url.toString() + "failed with HTTP status code: " + conn.getResponseCode());
      }

      responseStream = conn.getInputStream();
      responseStreamReader = new InputStreamReader(responseStream);

      return JSONObject.parse(responseStreamReader);

      } finally {
      if (responseStreamReader != null) {
        responseStreamReader.close();
      }
      if (responseStream != null) {
        responseStream.close();
      }
    }
  }

  private void extractDataValues(JSONArray viewItems,
                                 List<Double> randomValues,
                                 List<String> dataList,
                                 List<Long> times,
                                 List<String> formattedTimes) {
    randomValues.clear();
    times.clear();
    formattedTimes.clear();
    dataList.clear();

    SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss.SSS");
    Iterator i = viewItems.iterator();
//System.out.println(">>>> viewItems:\n" + viewItems);
    while (i.hasNext()) {
      JSONObject viewItem = (JSONObject)i.next();

      Long time = (Long)viewItem.get("collectionTime");
      times.add(time);
      String formattedTime = dateFormat.format(time);
      formattedTimes.add(formattedTime);

      JSONObject data = (JSONObject)viewItem.get("data");
      dataList.add(data.toString());
      Double randomValue = (Double)data.get("randomValue");
      randomValues.add(randomValue);
    }
  }

  private List<String> getTableData(List<Double> randomValues, List<Long> times, List<String> formattedTimes) {
      List<String> tableData = new ArrayList<String>();
      int lastRowIndex = randomValues.size() - 1;
//System.out.println(">>>> Rows: " + lastRowIndex);

      for(int i=0; i <= lastRowIndex; i++) {
        tableData.add("{\"time\": " + times.get(i) + ", \"displayTime\": \"" + formattedTimes.get(i) + "\", \"randomNumber\": " + randomValues.get(i) + "},");
      }

      // Don't want comma after last row
      String lastRow = tableData.get(lastRowIndex);
      tableData.set(lastRowIndex, lastRow.substring(0, lastRow.length() - 1));

      return tableData;
  }

  private List<String> getLineData(List<Long> times, List<Double> randomValues) {
    List<String> lineData = new ArrayList<String>();
    int lastRowIndex = randomValues.size() - 1;

    for(int i=0; i <= lastRowIndex; ++i) {
        lineData.add("{\"x\": " + times.get(i) + ", \"y\": " + randomValues.get(i) + "},");
    }

    // Don't want comma after last row
    String lastRow = lineData.get(lastRowIndex);
    lineData.set(lastRowIndex, lastRow.substring(0, lastRow.length() - 1));

    return lineData;
  }

  private void assembleFormattedData(List<String> lineData) throws IOException {
    Iterator<String> i;

    synchronized(_formattedData) {
      _formattedData.setLength(0);
      //_formattedData.append("{");
      _formattedData.append(lineData) ;
      //_formattedData.append("}");
    }
  }

  public String getFormattedData() {
    synchronized(_formattedData) {
      return _formattedData.toString();
    }
  }

  private class StreamsRestException extends Exception {
    private static final long serialVersionUID = 1L;
    public StreamsRestException(String msg) { super(msg); }
  }


  //
  // Thread which retrieves buffered streams data every second using the REST API
  //

  private class DataRetrievalThread extends Thread {
    URL _viewDataURL;

    private DataRetrievalThread(URL viewDataURL) {
      super("DataRetrievalThread ");
      _viewDataURL = viewDataURL;
    }

    public void run() {
      JSONArray viewItems;
      List<Double> randomValues = new ArrayList<Double>();
      List<String> dataList = new ArrayList<String>();
      List<Long> times = new ArrayList<Long>();
      List<String> formattedTimes = new ArrayList<String>();
      List<String> tableData;
      List<String> lineData;
      List<String> pieData;

      try {
        while(true) {
          JSONObject response = makeRestCall(_viewDataURL, _authToken);
          if(response != null) {
            viewItems = (JSONArray)response.get("viewItems");
            extractDataValues(viewItems, randomValues, dataList, times, formattedTimes);
//System.out.println(">>>>> dataList:\n" + dataList);

            //tableData = getTableData(randomValues, times, formattedTimes);
            //lineData = getLineData(times, randomValues);
            //pieData = getPieData(randomValues);

            assembleFormattedData(dataList);
          }
          Thread.sleep(10000);
        }
      }
      catch (Exception e) {
        SimpleDateFormat dateFormat = new SimpleDateFormat();
        System.out.println(dateFormat.format(System.currentTimeMillis()));
        System.out.println("Exception: " + e.getMessage());
        e.printStackTrace();
      }
    }
  }
}
